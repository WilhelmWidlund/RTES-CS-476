/* Main file for lab 1: interrupt time measurements
 */

#include <stdio.h>
#include "system.h"
#include "io.h"
#include "altera_avalon_pio_regs.h"
#include "altera_avalon_timer_regs.h"

#define COUNT_RZ		4
#define COUNT_Start		8
#define COUNT_Stop		12
#define COUNT_IntEn		16
#define COUNT_IntClr	20
#define COUNT_Target	24

// Configure the timer IP to be in continuous mode, with interrupts enabled, and start it
#define TIMER_settings	7

#define	Count_1secL		0xF080
#define	Count_1secH		0x02FA
#define arbval			0x0000ffff

int snapl;
int snaph;
int flag;



void test_parallel_port()
{
	IOWR_32DIRECT(PARALLELPORT_0_BASE, 0, 0x1234abcd);
	alt_printf("ParallelPort0=%x\n", IORD_32DIRECT(PARALLELPORT_0_BASE, 0));
}

void test_counter()
{
	IOWR_32DIRECT(COUNTER_0_BASE, COUNT_Target, Count_1sec);
	IOWR_32DIRECT(COUNTER_0_BASE, COUNT_RZ, arbval);
	alt_printf("iCounter after reset=%x\n", IORD_32DIRECT(COUNTER_0_BASE,0));
	alt_printf("iEn and iEOT=%x\n", IORD_32DIRECT(COUNTER_0_BASE, 20));
	IOWR_32DIRECT(COUNTER_0_BASE, COUNT_Start, arbval);
	alt_printf("iCounter while running=%x\n", IORD_32DIRECT(COUNTER_0_BASE,0));
	alt_printf("iEn and iEOT=%x\n", IORD_32DIRECT(COUNTER_0_BASE, 20));
	IOWR_32DIRECT(COUNTER_0_BASE, COUNT_Stop, arbval);
	alt_printf("iCounter, first read after stop=%x\n", IORD_32DIRECT(COUNTER_0_BASE,0));
	alt_printf("iCounter, second read after stop=%x\n", IORD_32DIRECT(COUNTER_0_BASE,0));
	alt_printf("iEn and iEOT=%x\n", IORD_32DIRECT(COUNTER_0_BASE, 20));
	IOWR_32DIRECT(COUNTER_0_BASE, COUNT_Start, arbval);
	alt_printf("iCounter, first read after restarting=%x\n", IORD_32DIRECT(COUNTER_0_BASE,0));
	alt_printf("iCounter, second read after restarting=%x\n", IORD_32DIRECT(COUNTER_0_BASE,0));
	alt_printf("iEn and iEOT=%x\n", IORD_32DIRECT(COUNTER_0_BASE, 20));
	IOWR_32DIRECT(COUNTER_0_BASE, COUNT_Stop, arbval);
}

void test_resptime(int type)
{
	// if type = 0, use parallel port
	// else, use printouts

	// Register isr
	alt_ic_isr_register(TIMER_0_IRQ_INTERRUPT_CONTROLLER_ID, TIMER_0_IRQ, resp_isr, 0, 0);
	// Initialize flag value
	flag = 0;
	// Initialize timer
	IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_0_BASE, 0);
	IOWR_ALTERA_AVALON_TIMER_PERIODL(TIMER_0_BASE, 0xF080);
	IOWR_ALTERA_AVALON_TIMER_PERIODH(TIMER_0_BASE, 0x02FA);
	IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_0_BASE, 7);
	// Setup loop structure
	counter = 0;
	max_iter = 10;
	accum_val = 0;
	avg_val = 0;
	while(counter < max_iter)
	{
		if(flag)
		{
			if(type != 0)
			{
				alt_printf("",)
			}
		}
	}
}

void test_recovtime(int type)
{

}

void resp_isr(void* context)
{
	IOWR_ALTERA_AVALON_TIMER_SNAPL(TIMER_0_BASE, arbval);
	IOWR_ALTERA_AVALON_TIMER_SNAPH(TIMER_0_BASE, arbval);
	snapl = IORD_ALTERA_AVALON_TIMER_SNAPL(TIMER_0_BASE);
	snaph = IORD_ALTERA_AVALON_TIMER_SNAPH(TIMER_0_BASE);
	IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_0_BASE, 2);
	flag = 1;
}

void recov_isr(void* context)
{

}

int main()
{
	test_parallel_port();
	test_counter();
	test_recovtime(0);
	return 0;
}
